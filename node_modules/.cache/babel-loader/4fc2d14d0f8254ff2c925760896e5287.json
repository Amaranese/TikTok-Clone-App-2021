{"ast":null,"code":"import React from 'react';\nimport { bool, func, node, number, object, oneOfType, string } from 'prop-types';\n\nvar debounce = function debounce(fn, time) {\n  var timeout = void 0;\n  return function () {\n    var _this = this,\n        _arguments = arguments;\n\n    var functionCall = function functionCall() {\n      return fn.apply(_this, _arguments);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(functionCall, time);\n  };\n}; // https://stackoverflow.com/questions/6860853/generate-random-string-for-div-id#6860916\n\n\nvar guidGenerator = function () {\n  var S4 = function S4() {\n    return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);\n  };\n\n  return S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4();\n};\n\nfunction getHighest(elements) {\n  var highest = 0;\n  elements.forEach(function (el) {\n    if (el.rect.height > highest) {\n      highest = el.rect.height;\n    }\n  });\n  return highest;\n}\n\nfunction nextTriggerOnMount(_ref) {\n  var rect = _ref.rect,\n      mode = _ref.mode,\n      prevOffset = _ref.prevOffset,\n      position = _ref.position,\n      direction = _ref.direction,\n      width = _ref.width;\n  if (mode !== 'chain') return false;\n\n  switch (direction) {\n    case 'toRight':\n      return position.from > 0;\n\n    case 'toLeft':\n    default:\n      return rect.width + position.from <= width;\n  }\n}\n\nfunction getFromOffset(_ref) {\n  var rect = _ref.rect,\n      offset = _ref.offset,\n      direction = _ref.direction;\n\n  switch (direction) {\n    case 'toRight':\n      return offset - rect.width;\n\n    case 'toLeft':\n    default:\n      return offset;\n  }\n}\n\nfunction getFrom(_ref2) {\n  var index = _ref2.index,\n      rect = _ref2.rect,\n      offset = _ref2.offset,\n      width = _ref2.width,\n      direction = _ref2.direction;\n  if (index === 0) return offset;\n\n  if (typeof offset === 'number') {\n    return getFromOffset({\n      rect: rect,\n      offset: offset,\n      direction: direction\n    });\n  }\n\n  switch (direction) {\n    case 'toRight':\n      return -rect.width;\n\n    case 'toLeft':\n    default:\n      return width;\n  }\n}\n\nfunction getTo(_ref3) {\n  var rect = _ref3.rect,\n      width = _ref3.width,\n      direction = _ref3.direction;\n\n  switch (direction) {\n    case 'toRight':\n      return width;\n\n    case 'toLeft':\n    default:\n      return -rect.width;\n  }\n}\n\nfunction getNext(_ref4) {\n  var mode = _ref4.mode,\n      from = _ref4.from,\n      direction = _ref4.direction,\n      rect = _ref4.rect,\n      width = _ref4.width;\n  var start = from || 0;\n\n  switch (mode) {\n    case 'await':\n      switch (direction) {\n        case 'toRight':\n          return width;\n\n        case 'toLeft':\n        default:\n          return -rect.width;\n      }\n\n    case 'smooth':\n      switch (direction) {\n        case 'toRight':\n          return rect.width > width ? 0 : width - rect.width;\n\n        case 'toLeft':\n        default:\n          return rect.width > width ? width - rect.width : 0;\n      }\n\n    case 'chain':\n    default:\n      switch (direction) {\n        case 'toRight':\n          return 0;\n\n        case 'toLeft':\n        default:\n          return rect.width + start > width ? width - rect.width : width - rect.left - rect.width;\n      }\n\n  }\n}\n\nvar getPosition = function (_ref5) {\n  var mode = _ref5.mode,\n      index = _ref5.index,\n      rect = _ref5.rect,\n      offset = _ref5.offset,\n      width = _ref5.width,\n      direction = _ref5.direction;\n  var from = getFrom({\n    index: index,\n    rect: rect,\n    offset: offset,\n    width: width,\n    direction: direction\n  });\n  var to = getTo({\n    rect: rect,\n    width: width,\n    direction: direction\n  });\n  return {\n    from: from,\n    to: to,\n    next: getNext({\n      mode: mode,\n      from: from,\n      direction: direction,\n      rect: rect,\n      width: width\n    })\n  };\n};\n\nfunction getNextOffset(_ref) {\n  var from = _ref.from,\n      rect = _ref.rect,\n      direction = _ref.direction;\n\n  switch (direction) {\n    case 'toRight':\n      {\n        return from;\n      }\n\n    case 'toLeft':\n    default:\n      {\n        return from + rect.width;\n      }\n  }\n}\n\nfunction getStartOffset(_ref) {\n  var offset = _ref.offset,\n      rect = _ref.rect,\n      direction = _ref.direction,\n      width = _ref.width;\n\n  if (offset === 'run-in') {\n    switch (direction) {\n      case 'toRight':\n        return -rect.width;\n\n      case 'toLeft':\n      default:\n        return width;\n    }\n  }\n\n  if (typeof offset === 'string') {\n    var offsetRelative = Number(offset.replace('%', ''));\n    if (offsetRelative) return width / 100 * offsetRelative;\n  }\n\n  return offset;\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar TickerElement = function (_React$Component) {\n  inherits(TickerElement, _React$Component);\n\n  function TickerElement() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, TickerElement);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TickerElement.__proto__ || Object.getPrototypeOf(TickerElement)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      children: _this.props.children({\n        index: _this.props.index\n      }),\n      move: _this.props.move,\n      position: {\n        from: undefined,\n        to: undefined,\n        next: undefined\n      },\n      offset: _this.props.offset,\n      rect: null\n    }, _this.x = 0, _this.isMoving = false, _this.nextTriggered = false, _this.elementRef = React.createRef(), _this.componentDidMount = function () {\n      _this.setPosition(true);\n\n      _this.observer = new MutationObserver(_this.onMutation);\n\n      _this.observer.observe(_this.elementRef.current, {\n        characterData: true,\n        childList: true,\n        subtree: true\n      });\n    }, _this.componentWillUnmount = function () {\n      _this.observer.disconnect();\n    }, _this.onMutation = function () {\n      _this.setPosition();\n    }, _this.componentDidUpdate = function (prevProps, prevState) {\n      if (!_this.x && prevState.position.from !== _this.state.position.from) {\n        _this.x = _this.state.position.from;\n        _this.elementRef.current.style.transform = 'translate3d(' + _this.x + 'px, 0, 0)';\n      }\n\n      if (_this.x !== _this.state.position.from && prevProps.prevRect && _this.props.prevRect && prevProps.prevRect.width !== _this.props.prevRect.width) {\n        if (_this.props.offset) {\n          _this.x = _this.x + (_this.props.offset - prevProps.offset);\n        } else {\n          _this.x = _this.x + (_this.props.prevRect.width - prevProps.prevRect.width);\n        }\n\n        _this.elementRef.current.style.transform = 'translate3d(' + _this.x + 'px, 0, 0)';\n      }\n\n      if (_this.props.move && !prevProps.start && _this.props.start) {\n        _this.animate();\n      }\n\n      if (_this.props.start && !prevProps.move && _this.props.move) {\n        _this.animate();\n      }\n\n      if (prevProps.move && !_this.props.move) {\n        _this.isMoving = false;\n      }\n    }, _this.setPosition = function (isMount) {\n      var _this$props = _this.props,\n          mode = _this$props.mode,\n          width = _this$props.width,\n          id = _this$props.id,\n          onNext = _this$props.onNext,\n          direction = _this$props.direction,\n          index = _this$props.index,\n          setRect = _this$props.setRect;\n\n      var rect = _this.elementRef.current.getBoundingClientRect();\n\n      if (rect.width === 0) return;\n      var offset = _this.props.index === 0 ? getStartOffset({\n        offset: _this.props.offset,\n        rect: rect,\n        direction: direction,\n        width: width\n      }) : _this.props.offset;\n      var position = getPosition({\n        mode: mode,\n        rect: rect,\n        index: index,\n        offset: offset,\n        width: width,\n        direction: direction\n      });\n      setRect({\n        index: _this.props.index,\n        rect: rect,\n        offset: offset,\n        nextOffset: getNextOffset({\n          from: position.from,\n          rect: rect,\n          direction: direction\n        })\n      });\n\n      if (isMount) {\n        var nextTriggerOnMount$$1 = nextTriggerOnMount({\n          mode: mode,\n          rect: rect,\n          position: position,\n          offset: offset,\n          direction: direction,\n          width: width\n        });\n\n        if (nextTriggerOnMount$$1) {\n          onNext({\n            id: id,\n            index: index,\n            rect: rect,\n            nextOffset: getNextOffset({\n              from: position.from,\n              rect: rect,\n              direction: direction\n            })\n          });\n        }\n\n        if (!nextTriggerOnMount$$1 && (offset || index === 0)) {\n          onNext({\n            id: id,\n            index: index,\n            rect: rect\n          });\n        }\n\n        _this.nextTriggered = nextTriggerOnMount$$1;\n      }\n\n      _this.setState({\n        rect: rect,\n        offset: offset,\n        position: position\n      });\n    }, _this.shouldTriggerNext = function () {\n      if (_this.nextTriggered) return false;\n      return _this.props.direction === 'toLeft' ? _this.x <= _this.state.position.next : _this.x >= _this.state.position.next;\n    }, _this.triggerNext = function () {\n      if (_this.shouldTriggerNext()) {\n        // if (this.props.index === 5) console.log(this.x)\n        _this.nextTriggered = true;\n\n        _this.props.onNext({\n          id: _this.props.id,\n          index: _this.props.index,\n          rect: _this.state.rect\n        });\n      }\n    }, _this.shouldFinish = function () {\n      switch (_this.props.direction) {\n        case 'toRight':\n          return _this.x >= _this.state.position.to;\n\n        case 'toLeft':\n        default:\n          return _this.x <= _this.state.position.to;\n      }\n    }, _this.animate = function () {\n      if (_this.isMoving) return;\n      _this.isMoving = true;\n      var prevTimestamp = null;\n\n      var step = function step(timestamp) {\n        if (!_this.isMoving) return;\n        if (!_this.elementRef.current) return;\n        var progress = prevTimestamp ? timestamp - prevTimestamp : 0;\n        _this.x = _this.props.direction === 'toLeft' ? _this.x - progress / 100 * _this.props.speed : _this.x + progress / 100 * _this.props.speed;\n        _this.elementRef.current.style.transform = 'translate3d(' + _this.x + 'px, 0, 0)';\n\n        _this.triggerNext();\n\n        if (_this.shouldFinish()) {\n          _this.isMoving = false;\n          prevTimestamp = null;\n\n          _this.props.onFinish(_this.props.id);\n        } else {\n          prevTimestamp = timestamp;\n          window.requestAnimationFrame(step);\n        }\n      };\n\n      window.requestAnimationFrame(step);\n    }, _this.render = function () {\n      return React.createElement('div', {\n        className: 'ticker__element',\n        style: {\n          willChange: 'transform',\n          position: 'absolute',\n          left: 0,\n          top: 0,\n          transform: 'translate3d(' + _this.x + 'px, 0, 0)'\n        },\n        ref: _this.elementRef\n      }, _this.state.children);\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  return TickerElement;\n}(React.Component);\n\nTickerElement.propTypes = {\n  children: oneOfType([node, func]).isRequired,\n  direction: string.isRequired,\n  speed: number.isRequired,\n  id: string.isRequired,\n  index: number.isRequired,\n  mode: string.isRequired,\n  move: bool.isRequired,\n  onNext: func.isRequired,\n  onFinish: func.isRequired,\n  setRect: func.isRequired,\n  start: bool.isRequired,\n  offset: oneOfType([number, string]),\n  prevRect: object,\n  width: number\n};\nTickerElement.defaultProps = {\n  offset: undefined,\n  width: undefined,\n  prevRect: null\n};\n\nvar getDefaultState = function getDefaultState(offset, width) {\n  return {\n    elements: [{\n      id: guidGenerator(),\n      index: 0,\n      height: 0,\n      start: false,\n      offset: offset,\n      rect: null,\n      prevRect: null\n    }],\n    width: width,\n    height: 0\n  };\n};\n\nvar Ticker = function (_React$Component) {\n  inherits(Ticker, _React$Component);\n\n  function Ticker() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Ticker);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Ticker.__proto__ || Object.getPrototypeOf(Ticker)).call.apply(_ref, [this].concat(args))), _this), _this.next = null, _this.state = getDefaultState(_this.props.offset), _this.tickerRef = React.createRef(), _this.dOnResize = debounce(function () {\n      return _this.onResize();\n    }, 150), _this.componentDidMount = function () {\n      _this.setState({\n        width: _this.tickerRef.current.offsetWidth,\n        height: _this.props.height\n      });\n\n      window.addEventListener('resize', _this.dOnResize);\n    }, _this.componentWillUnmount = function () {\n      window.removeEventListener('resize', _this.dOnResize);\n    }, _this.setRect = function (_ref2) {\n      var index = _ref2.index,\n          rect = _ref2.rect,\n          offset = _ref2.offset,\n          nextOffset = _ref2.nextOffset;\n\n      _this.setState(function (prevState) {\n        var elements = prevState.elements.map(function (el) {\n          var newEl = el;\n          if (el.index === index) newEl.rect = rect; // next element\n\n          if (el.index === index + 1) {\n            newEl.prevRect = rect;\n\n            if (newEl.offset) {\n              newEl.offset = nextOffset;\n            }\n          }\n\n          return newEl;\n        });\n        return {\n          elements: elements,\n          height: _this.props.height ? prevState.height : getHighest(elements)\n        };\n      });\n    }, _this.onResize = function () {\n      if (!_this.tickerRef.current || _this.tickerRef.current.offsetWidth === _this.state.width) return;\n\n      _this.setState(_extends({}, getDefaultState(_this.props.offset, _this.tickerRef.current.offsetWidth), {\n        height: _this.props.height\n      }));\n    }, _this.onFinish = function (id) {\n      _this.setState(function (prevState) {\n        return {\n          elements: prevState.elements.filter(function (el) {\n            return el.id !== id;\n          })\n        };\n      });\n    }, _this.onNext = function (_ref3) {\n      var id = _ref3.id,\n          index = _ref3.index,\n          rect = _ref3.rect,\n          nextOffset = _ref3.nextOffset;\n\n      _this.setState(function (prevState) {\n        return {\n          elements: [].concat(toConsumableArray(prevState.elements.map(function (el) {\n            var newEl = el;\n            if (el.index === index) newEl.rect = rect;\n\n            if (el.index === 0 || el.offset || newEl.index === index + 1) {\n              newEl.start = true;\n            }\n\n            return newEl; // create new element\n          })), [{\n            id: guidGenerator(),\n            index: prevState.elements[prevState.elements.length - 1].index + 1,\n            height: 0,\n            start: false,\n            offset: nextOffset,\n            rect: null,\n            prevRect: rect\n          }])\n        };\n      });\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n\n  createClass(Ticker, [{\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      return React.createElement('div', {\n        className: 'ticker',\n        ref: this.tickerRef,\n        style: {\n          position: 'relative',\n          overflow: 'hidden',\n          height: this.state.height && this.state.height + 'px'\n        }\n      }, this.state.width && this.state.elements.map(function (el) {\n        return React.createElement(TickerElement, {\n          key: el.id,\n          id: el.id,\n          index: el.index,\n          start: el.start,\n          offset: el.offset,\n          prevRect: el.prevRect,\n          direction: _this2.props.direction,\n          mode: _this2.props.mode,\n          move: _this2.props.move,\n          speed: _this2.props.speed,\n          onFinish: _this2.onFinish,\n          onNext: _this2.onNext,\n          setRect: _this2.setRect,\n          width: _this2.state.width\n        }, _this2.props.children);\n      }));\n    }\n  }]);\n  return Ticker;\n}(React.Component);\n\nTicker.propTypes = {\n  children: oneOfType([node, func]).isRequired,\n  direction: string,\n  mode: string,\n  move: bool,\n  offset: oneOfType([number, string]),\n  speed: number,\n  height: oneOfType([number, string])\n};\nTicker.defaultProps = {\n  offset: 0,\n  speed: 5,\n  direction: 'toLeft',\n  mode: 'chain',\n  move: true,\n  height: undefined\n};\nexport default Ticker;","map":{"version":3,"sources":["../src/utils/debounce.js","../src/utils/guidGenerator.js","../src/utils/getHighest.js","../src/utils/shouldNextTriggerOnMount.js","../src/utils/getPosition.js","../src/utils/getNextOffset.js","../src/utils/getStartOffset.js","../src/Element.js","../src/utils/getDefaultState.js","../src/index.js"],"names":["debounce","timeout","functionCall","fn","setTimeout","S4","Math","highest","el","rect","mode","prevOffset","position","direction","width","offset","index","getFromOffset","from","start","getFrom","to","getTo","getNext","offsetRelative","Number","TickerElement","React","Component","propTypes","oneOfType","string","number","bool","func","defaultProps","state","next","x","isMoving","nextTriggered","elementRef","componentDidMount","characterData","childList","subtree","componentWillUnmount","onMutation","componentDidUpdate","prevState","prevProps","setPosition","id","onNext","setRect","getStartOffset","getPosition","getNextOffset","nextTriggerOnMount","shouldNextTriggerOnMount","shouldTriggerNext","triggerNext","shouldFinish","animate","prevTimestamp","step","progress","timestamp","render","children","getDefaultState","guidGenerator","Ticker","undefined","tickerRef","dOnResize","height","nextOffset","elements","newEl","getHighest","onResize","onFinish"],"mappings":"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","sourcesContent":["const debounce = (fn, time) => {\n  let timeout\n\n  return function () {\n    const functionCall = () => fn.apply(this, arguments)\n\n    clearTimeout(timeout)\n    timeout = setTimeout(functionCall, time)\n  }\n}\n\nexport default debounce\n","// https://stackoverflow.com/questions/6860853/generate-random-string-for-div-id#6860916\n\nexport default () => {\n  const S4 = () => (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1)\n  return (S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4())\n}\n","export default function getHighest(elements) {\n  let highest = 0\n  elements.forEach(el => {\n    if (el.rect.height > highest) {\n      highest = el.rect.height\n    }\n  })\n  return highest\n}\n","export default function nextTriggerOnMount({ rect, mode, prevOffset, position, direction, width }) {\n  if (mode !== 'chain') return false\n  switch (direction) {\n    case 'toRight':\n      return position.from > 0\n    case 'toLeft':\n    default:\n      return rect.width + position.from <= width\n  }\n}\n","function getFromOffset({ rect, offset, direction }) {\n  switch (direction) {\n    case 'toRight':\n      return offset - rect.width\n    case 'toLeft':\n    default:\n      return offset\n  }\n}\n\nfunction getFrom({ index, rect, offset, width, direction }) {\n  if (index === 0) return offset\n\n  if (typeof offset === 'number') {\n    return getFromOffset({ rect, offset, direction })\n  }\n\n  switch (direction) {\n    case 'toRight':\n      return -rect.width\n    case 'toLeft':\n    default:\n      return width\n  }\n}\n\nfunction getTo({ rect, width, direction }) {\n  switch (direction) {\n    case 'toRight':\n      return width\n    case 'toLeft':\n    default:\n      return -rect.width\n  }\n}\n\nfunction getNext({ mode, from, direction, rect, width }) {\n  const start = from || 0\n\n  switch (mode) {\n    case 'await':\n      switch (direction) {\n        case 'toRight':\n          return width\n        case 'toLeft':\n        default:\n          return -rect.width\n      }\n    case 'smooth':\n      switch (direction) {\n        case 'toRight':\n          return rect.width > width\n            ? 0\n            : width - rect.width\n        case 'toLeft':\n        default:\n          return rect.width > width\n            ? width - rect.width\n            : 0\n      }\n    case 'chain':\n    default:\n      switch (direction) {\n        case 'toRight':\n          return 0\n        case 'toLeft':\n        default:\n          return rect.width + start > width\n            ? width - rect.width\n            : width - rect.left - rect.width\n      }\n  }\n}\n\nexport default ({ mode, index, rect, offset, width, direction }) => {\n  const from = getFrom({ index, rect, offset, width, direction })\n  const to = getTo({ rect, width, direction })\n  return {\n    from,\n    to,\n    next: getNext({ mode, from, direction, rect, width })\n  }\n}\n","export default function getNextOffset({ from, rect, direction }) {\n  switch (direction) {\n    case 'toRight': {\n      return from\n    }\n    case 'toLeft':\n    default: {\n      return from + rect.width\n    }\n  }\n}\n","export default function getStartOffset({ offset, rect, direction, width }) {\n  if (offset === 'run-in') {\n    switch (direction) {\n      case 'toRight':\n        return -rect.width\n      case 'toLeft':\n      default:\n        return width\n    }\n  }\n  if (typeof offset === 'string') {\n    const offsetRelative = Number(offset.replace('%', ''))\n    if (offsetRelative) return (width / 100) * offsetRelative\n  }\n  return offset\n}\n","import React from 'react'\nimport { bool, func, node, number, object, oneOfType, string } from 'prop-types'\n\nimport shouldNextTriggerOnMount from './utils/shouldNextTriggerOnMount'\nimport getPosition from './utils/getPosition'\nimport getNextOffset from './utils/getNextOffset'\nimport getStartOffset from './utils/getStartOffset'\n\nclass TickerElement extends React.Component {\n  static propTypes = {\n    children: oneOfType([node, func]).isRequired,\n    direction: string.isRequired,\n    speed: number.isRequired,\n    id: string.isRequired,\n    index: number.isRequired,\n    mode: string.isRequired,\n    move: bool.isRequired,\n    onNext: func.isRequired,\n    onFinish: func.isRequired,\n    setRect: func.isRequired,\n    start: bool.isRequired,\n\n    offset: oneOfType([number, string]),\n    prevRect: object,\n    width: number\n  }\n\n  static defaultProps = {\n    offset: undefined,\n    width: undefined,\n    prevRect: null\n  }\n\n  state = {\n    children: this.props.children({\n      index: this.props.index\n    }),\n    move: this.props.move,\n    position: { from: undefined, to: undefined, next: undefined },\n    offset: this.props.offset,\n    rect: null\n  }\n  x = 0\n  isMoving = false\n  nextTriggered = false\n  elementRef = React.createRef()\n\n  componentDidMount = () => {\n    this.setPosition(true)\n    this.observer = new MutationObserver(this.onMutation)\n    this.observer.observe(this.elementRef.current, { characterData: true, childList: true, subtree: true })\n  }\n\n  componentWillUnmount = () => {\n    this.observer.disconnect()\n  }\n\n  onMutation = () => {\n    this.setPosition()\n  }\n\n  componentDidUpdate = (prevProps, prevState) => {\n    if (!this.x && prevState.position.from !== this.state.position.from) {\n      this.x = this.state.position.from\n      this.elementRef.current.style.transform = `translate3d(${this.x}px, 0, 0)`\n    }\n    if (this.x !== this.state.position.from &&\n      prevProps.prevRect &&\n      this.props.prevRect &&\n      prevProps.prevRect.width !== this.props.prevRect.width) {\n      if (this.props.offset) {\n        this.x = this.x + (this.props.offset - prevProps.offset)\n      } else {\n        this.x = this.x + (this.props.prevRect.width - prevProps.prevRect.width)\n      }\n      this.elementRef.current.style.transform = `translate3d(${this.x}px, 0, 0)`\n    }\n    if (this.props.move && !prevProps.start && this.props.start) {\n      this.animate()\n    }\n    if (this.props.start && !prevProps.move && this.props.move) {\n      this.animate()\n    }\n    if (prevProps.move && !this.props.move) {\n      this.isMoving = false\n    }\n  }\n\n  setPosition = (isMount) => {\n    const {\n      mode,\n      width,\n      id,\n      onNext,\n      direction,\n      index,\n      setRect\n    } = this.props\n\n    const rect = this.elementRef.current.getBoundingClientRect()\n    if (rect.width === 0) return\n\n    const offset = this.props.index === 0\n      ? getStartOffset({ offset: this.props.offset, rect, direction, width })\n      : this.props.offset\n\n    const position = getPosition({ mode, rect, index, offset, width, direction })\n\n    setRect({\n      index: this.props.index,\n      rect,\n      offset,\n      nextOffset: getNextOffset({ from: position.from, rect, direction })\n    })\n\n    if (isMount) {\n      const nextTriggerOnMount = shouldNextTriggerOnMount({ mode, rect, position, offset, direction, width })\n      if (nextTriggerOnMount) {\n        onNext({\n          id,\n          index,\n          rect,\n          nextOffset: getNextOffset({ from: position.from, rect, direction })\n        })\n      }\n      if (!nextTriggerOnMount && (offset || index === 0)) {\n        onNext({ id, index, rect })\n      }\n      this.nextTriggered = nextTriggerOnMount\n    }\n\n    this.setState({\n      rect,\n      offset,\n      position\n    })\n  }\n\n  shouldTriggerNext = () => {\n    if (this.nextTriggered) return false\n    return this.props.direction === 'toLeft'\n      ? this.x <= this.state.position.next\n      : this.x >= this.state.position.next\n  }\n\n  triggerNext = () => {\n    if (this.shouldTriggerNext()) {\n      // if (this.props.index === 5) console.log(this.x)\n      this.nextTriggered = true\n      this.props.onNext({\n        id: this.props.id,\n        index: this.props.index,\n        rect: this.state.rect\n      })\n    }\n  }\n\n  shouldFinish = () => {\n    switch (this.props.direction) {\n      case 'toRight':\n        return this.x >= this.state.position.to\n      case 'toLeft':\n      default:\n        return this.x <= this.state.position.to\n    }\n  }\n\n  animate = () => {\n    if (this.isMoving) return\n    this.isMoving = true\n\n    let prevTimestamp = null\n\n    const step = (timestamp) => {\n      if (!this.isMoving) return\n      if (!this.elementRef.current) return\n\n      const progress = prevTimestamp\n        ? timestamp - prevTimestamp\n        : 0\n\n      this.x = this.props.direction === 'toLeft'\n        ? this.x - (progress / 100 * this.props.speed)\n        : this.x + (progress / 100 * this.props.speed)\n      this.elementRef.current.style.transform = `translate3d(${this.x}px, 0, 0)`\n      this.triggerNext()\n\n      if (this.shouldFinish()) {\n        this.isMoving = false\n        prevTimestamp = null\n        this.props.onFinish(this.props.id)\n      } else {\n        prevTimestamp = timestamp\n        window.requestAnimationFrame(step)\n      }\n    }\n    window.requestAnimationFrame(step)\n  }\n\n  render = () => (\n    <div\n      className='ticker__element'\n      style={{\n        willChange: 'transform',\n        position: 'absolute',\n        left: 0,\n        top: 0,\n        transform: `translate3d(${this.x}px, 0, 0)`\n      }}\n      ref={this.elementRef}\n    >\n      {this.state.children}\n    </div>\n  )\n}\n\nexport default TickerElement\n","\nimport guidGenerator from './guidGenerator'\n\nconst getDefaultState = (offset, width) => ({\n  elements: [{\n    id: guidGenerator(),\n    index: 0,\n    height: 0,\n    start: false,\n    offset: offset,\n    rect: null,\n    prevRect: null\n  }],\n  width,\n  height: 0\n})\n\nexport default getDefaultState\n","import React from 'react'\nimport { bool, func, node, number, oneOfType, string } from 'prop-types'\nimport debounce from './utils/debounce'\nimport guidGenerator from './utils/guidGenerator'\nimport getHighest from './utils/getHighest'\nimport TickerElement from './Element'\nimport getDefaultState from './utils/getDefaultState'\n\nexport default class Ticker extends React.Component {\n  static propTypes = {\n    children: oneOfType([node, func]).isRequired,\n\n    direction: string,\n    mode: string,\n    move: bool,\n    offset: oneOfType([number, string]),\n    speed: number,\n    height: oneOfType([number, string])\n  }\n\n  static defaultProps = {\n    offset: 0,\n    speed: 5,\n    direction: 'toLeft',\n    mode: 'chain',\n    move: true,\n    height: undefined\n  }\n  next = null\n  state = getDefaultState(this.props.offset)\n  tickerRef = React.createRef()\n\n  dOnResize = debounce(() => this.onResize(), 150)\n\n  componentDidMount = () => {\n    this.setState({\n      width: this.tickerRef.current.offsetWidth,\n      height: this.props.height\n    })\n    window.addEventListener('resize', this.dOnResize)\n  }\n\n  componentWillUnmount = () => {\n    window.removeEventListener('resize', this.dOnResize)\n  }\n\n  setRect = ({ index, rect, offset, nextOffset }) => {\n    this.setState(prevState => {\n      const elements = prevState.elements.map(el => {\n        const newEl = el\n        if (el.index === index) newEl.rect = rect\n        // next element\n        if (el.index === index + 1) {\n          newEl.prevRect = rect\n          if (newEl.offset) {\n            newEl.offset = nextOffset\n          }\n        }\n        return newEl\n      })\n      return {\n        elements,\n        height: this.props.height\n          ? prevState.height\n          : getHighest(elements)\n      }\n    })\n  }\n\n  onResize = () => {\n    if (!this.tickerRef.current || this.tickerRef.current.offsetWidth === this.state.width) return\n    this.setState({\n      ...getDefaultState(this.props.offset, this.tickerRef.current.offsetWidth),\n      height: this.props.height\n    })\n  }\n\n  onFinish = (id) => {\n    this.setState(prevState => ({\n      elements: prevState.elements.filter(el => el.id !== id)\n    }))\n  }\n\n  onNext = ({ id, index, rect, nextOffset }) => {\n    this.setState(prevState => ({\n      elements: [\n        // start next element\n        ...prevState.elements.map(el => {\n          const newEl = el\n          if (el.index === index) newEl.rect = rect\n          if (el.index === 0 || el.offset || newEl.index === index + 1) {\n            newEl.start = true\n          }\n          return newEl\n          // create new element\n        }), {\n          id: guidGenerator(),\n          index: prevState.elements[prevState.elements.length - 1].index + 1,\n          height: 0,\n          start: false,\n          offset: nextOffset,\n          rect: null,\n          prevRect: rect\n        }\n      ]\n    }))\n  }\n\n  render() {\n    return (\n      <div\n        className='ticker'\n        ref={this.tickerRef}\n        style={{\n          position: 'relative',\n          overflow: 'hidden',\n          height: this.state.height && `${this.state.height}px`\n        }}\n      >\n        {\n          this.state.width && this.state.elements.map(el => {\n            return (\n              <TickerElement\n                key={el.id}\n                id={el.id}\n                index={el.index}\n                start={el.start}\n                offset={el.offset}\n                prevRect={el.prevRect}\n\n                direction={this.props.direction}\n                mode={this.props.mode}\n                move={this.props.move}\n                speed={this.props.speed}\n\n                onFinish={this.onFinish}\n                onNext={this.onNext}\n                setRect={this.setRect}\n                width={this.state.width}\n              >\n                {this.props.children}\n              </TickerElement>\n            )\n          })\n        }\n      </div>\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"module"}